<!doctype html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<title>Test Results</title>
<link type="text/css" rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
onload="renderMathInElement(document.body);"></script>
<script>
    // https://github.com/KaTeX/KaTeX/blob/main/docs/autorender.md
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            // customised options
            // auto-render specific keys, e.g.:
                delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true},
                {left: "\begin{equation}", right: "\end{equation}", display: true},
                {left: "\begin{align}", right: "\end{align}", display: true},
            ],
            // rendering keys, e.g.:
            throwOnError : false
        });
    });
 </script>

</head>
<body>
<main>

<p>
<nav class="crumbs">
</p>

<ul><li>
<p>
<a href="../index.html">ysg</a>
</p>
</li>
<li>
<p>
<a href="../sml/index.html">sml</a>
</p>
</li>
<li>
<p>
<a href="./index.html">xunit</a>
</p>
</li>
<li>
<p>
result
</p>
</li>
</ul>

<p>
</nav>
</p>

<h1>Test Results</h1>

<h2>Specification for Test Result Module</h2>

<p>
The common practice is that, when we're describing a data structure,
we create a module for it with a <code>type t</code> for the type of the data
structure. We follow this rule when specifyign the test result module.
</p>

<p>
We need the following methods:
</p>

<ul><li>
<p>
Smart constructors which will run a test case (or test suite) once,
and record all the information for it. These will
be <code>TestResult.for_case</code> and <code>TestResult.for_suite</code>
</p>
</li>
<li>
<p>
Reporting results. We don't know what the user will want. So we
allow the user to give us two functions <code>report_case : t -&gt; string</code> 
and <code>report_suite : t -&gt; t list -&gt; string</code> which will then
parametrize a function <code>t -&gt; string</code> reporting the results of a
particular run to the user as a string.
</p>
</li>
<li>
<p>
We want accessor functions for various fields.
</p>
</li>
<li>
<p>
We want predicates testing if the test result records a success,
failure, or error.
</p>
</li>
<li>
<p>
We want to count the number of successes, failures, and errors which
occurred when running a test. For test cases, these will be at most
1.
</p>
</li>
</ul>

<p>
And that's it! It <i>sounds</i> scarier than it is. Let us scribble this
specification down, then run over to its implementation.
</p>

<p>
(Note: if the user <i>wants</i> to capture everything printed to <code>stdout</code>
and <code>stderr</code>, Reppy and Gansner's <cite class="book">The Standard ML
Basis Library</cite> gives some pointers in section 8.2.4.)
</p>

<pre data-lang="sml" class="src"><span class="c">(*
TODO: capture everything printed to stdout and stderr, then
allow the user access to these strings.
*)</span>
<span class="k">signature</span> <span class="n">TEST_RESULT</span> <span class="n">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">for_case</span> <span class="n">:</span> <span class="n">string</span> <span class="n">-&gt;</span> <span class="p">(</span><span class="n">unit</span> <span class="n">-&gt;</span> <span class="n">unit</span><span class="p">)</span> <span class="n">-&gt;</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">for_suite</span> <span class="n">:</span> <span class="n">string</span> <span class="n">-&gt;</span> <span class="p">(</span><span class="n">unit</span> <span class="n">-&gt;</span> <span class="p">(</span><span class="n">t</span> <span class="n">list</span><span class="p">)</span><span class="p">)</span> <span class="n">-&gt;</span> <span class="n">t</span><span class="p">;</span>

  <span class="k">val</span> <span class="n">report</span> <span class="n">:</span> <span class="p">(</span><span class="n">t</span> <span class="n">-&gt;</span> <span class="n">string</span><span class="p">)</span> <span class="n">-&gt;</span> <span class="p">(</span><span class="n">t</span> <span class="n">-&gt;</span> <span class="n">t</span> <span class="n">list</span> <span class="n">-&gt;</span> <span class="n">string</span><span class="p">)</span> <span class="n">-&gt;</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">string</span><span class="p">;</span>

  <span class="k">val</span> <span class="n">name</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">string</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">msg</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">string</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">exn_message</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">string</span><span class="p">;</span>
  <span class="c">(* realtime excludes the time it took a TestSuite to
   allocate infrastructure in memory. *)</span>
  <span class="k">val</span> <span class="n">realtime</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">Time</span>.<span class="n">time</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">runtime</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">Time</span>.<span class="n">time</span><span class="p">;</span>
  
  <span class="k">val</span> <span class="n">is_success</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">bool</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">is_failure</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">bool</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">is_error</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">bool</span><span class="p">;</span>

  <span class="k">val</span> <span class="n">count_successes</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">int</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">count_failures</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">int</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">count_errors</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">int</span><span class="p">;</span>
  <span class="k">val</span> <span class="n">count_total</span> <span class="n">:</span> <span class="n">t</span> <span class="n">-&gt;</span> <span class="n">int</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span></pre>

<h2>Types for Test Results</h2>

<p>
The first thing we want to do is introduce types for test
results.
</p>

<p>
First, there is the type describing the conceivable outcomes of a
test. We agreed that a test could: succeed, fail with a message, or an
exception could be raised (and we'd count this as an "error"
situation).
</p>

<p>
Then, when we run a test case, we want to store its name, the time
interval for running the test, and the outcome.
</p>

<p>
When running a test suite, we want to remember its name, the time
interval it took to run it, and the results for every test in the
suite (<b>NOT</b> the outcomes &mdash; what good would this do for nested
test suites?).
</p>

<pre data-lang="sml" class="src"><span class="k">structure</span> <span class="n">TestResult</span> <span class="n">:&gt;</span> <span class="n">TEST_RESULT</span> <span class="n">=</span> <span class="k">struct</span>
  <span class="k">datatype</span> <span class="n">Outcome</span> <span class="n">=</span> <span class="n">Success</span>
                   <span class="n">|</span> <span class="n">Failure</span> <span class="k">of</span> <span class="n">string</span>
                   <span class="n">|</span> <span class="n">Error</span> <span class="k">of</span> <span class="n">exn</span><span class="p">;</span>
  
  <span class="k">datatype</span> <span class="n">t</span> <span class="n">=</span> <span class="n">Case</span> <span class="k">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">Time</span>.<span class="n">time</span> <span class="n">*</span> <span class="n">Outcome</span>
             <span class="n">|</span> <span class="n">Suite</span> <span class="k">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">Time</span>.<span class="n">time</span> <span class="n">*</span> <span class="p">(</span><span class="n">t</span> <span class="n">list</span><span class="p">)</span><span class="p">;</span></pre>

<h2>Smart Constructors</h2>

<p>
OK, the basic plan for constructing a test result for a test case is:
</p>

<ul><li>
<p>
Given the name (as a string) and the four-phase procedure as a
function
</p>
</li>
<li>
<p>
We will record the start time
</p>
</li>
<li>
<p>
Then we will execute the four-phase assertion function.
</p>
</li>
<li>
<p>
In the default case (no exception is raised), we record the stop
time, and construct a result object for a test case saving the name,
time interval, and a "success" outcome. This is returned to the
user.
</p>
</li>
<li>
<p>
If an <code>Assert.Failure msg</code> was raised, then we record the stop time,
and construct a test result instance with a "failure" outcome
(saving the <code>msg</code> parameter). Then we return this to the user.
</p>
</li>
<li>
<p>
If any other exception <code>e</code> was raised, we record the stop time, and
construct the test result recording the test case's name, the time
interval it took to run, and that an "error" outcome with exception
<code>e</code> occurred.
</p>
</li>
</ul>

<p>
Strictly speaking, we could use a <a href="https://smlfamily.github.io/Basis/timer.html"><code>Timer</code></a>
if we wanted to check the CPU time consumed.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">for_case</span> <span class="n">name</span> <span class="n">assertion</span> <span class="n">=</span>
    <span class="k">let</span>
      <span class="k">val</span> <span class="n">start</span> <span class="n">=</span> <span class="n">Time</span>.<span class="n">now</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="k">in</span>
      <span class="p">(</span><span class="n">assertion</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
       <span class="n">Case</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Time</span>.<span class="n">-</span><span class="p">)</span><span class="p">(</span><span class="n">Time</span>.<span class="n">now</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span><span class="p">,</span>
            <span class="n">Success</span><span class="p">)</span><span class="p">)</span>
      <span class="k">handle</span> <span class="n">Assert</span>.<span class="n">Failure</span> <span class="n">msg</span> <span class="n">=&gt;</span>
             <span class="n">Case</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span>
                   <span class="p">(</span><span class="n">Time</span>.<span class="n">-</span><span class="p">)</span><span class="p">(</span><span class="n">Time</span>.<span class="n">now</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span><span class="p">,</span>
                   <span class="n">Failure</span> <span class="n">msg</span><span class="p">)</span>
             <span class="n">|</span> <span class="n">e</span> <span class="n">=&gt;</span> <span class="n">Case</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
                         <span class="p">(</span><span class="n">Time</span>.<span class="n">-</span><span class="p">)</span><span class="p">(</span><span class="n">Time</span>.<span class="n">now</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span><span class="p">,</span>
                         <span class="n">Error</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">end</span><span class="p">;</span></pre>

<p>
For a test suite, we simply record the start time, then determine the
results for every test in the suite. Once these results have been
tabulated, we record the interval <code>dt</code> it took to run all these tests.
</p>

<p>
Then we save these results in a test result object for a test suite.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">for_suite</span> <span class="n">name</span> <span class="n">form_results</span> <span class="n">=</span>
    <span class="k">let</span>
      <span class="k">val</span> <span class="n">start</span> <span class="n">=</span> <span class="n">Time</span>.<span class="n">now</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
      <span class="k">val</span> <span class="n">results</span> <span class="n">=</span> <span class="n">form_results</span> <span class="p">(</span><span class="p">)</span><span class="p">;</span>
      <span class="k">val</span> <span class="n">dt</span> <span class="n">=</span> <span class="p">(</span><span class="n">Time</span>.<span class="n">-</span><span class="p">)</span><span class="p">(</span><span class="n">Time</span>.<span class="n">now</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span><span class="p">;</span>
    <span class="k">in</span>
      <span class="n">Suite</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
    <span class="k">end</span><span class="p">;</span></pre>

<h2>Accessor functions</h2>

<p>
We want to hide the implementation details <b>entirely</b> from the user. 
This forces us to produce a large number of functions for obtaining
information about a test result.
</p>

<p>
The user may want to know the name of the test which was run. This is
a simple accessor function.
</p>

<pre data-lang="sml" class="src"><span class="c">(* *** accessor functions *** *)</span>
  
  <span class="k">fun</span> <span class="n">name</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">n</span>
    <span class="n">|</span> <span class="n">name</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">n</span><span class="p">;</span></pre>

<p>
Now, we may want to know the time it took to run the test. This will
possibly include some overhead from the test suite, so we offer two
functions for determining the time it took: the <code>runtime</code> is simply
the time intervals stored in the test result object.
</p>

<p>
The <code>real_time</code> computes the time interval for results from test
suites by summing the time intervals in the result objects for
test cases only. These two functions are the same for test case
results.
</p>

<pre data-lang="sml" class="src">  <span class="c">(* runtime : t -&gt; Time.time

How long did it take to run the test(s) and construct the
result(s)? *)</span>
  <span class="k">fun</span> <span class="n">runtime</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">dt</span>
    <span class="n">|</span> <span class="n">runtime</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">dt</span><span class="p">;</span>

  <span class="c">(* realtime : t -&gt; Time.time

How long did it take just to run the test(s)? *)</span>
  <span class="k">fun</span> <span class="n">realtime</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">dt</span>
    <span class="n">|</span> <span class="n">realtime</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">Time</span>.<span class="n">zeroTime</span>
    <span class="n">|</span> <span class="n">realtime</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">realtime</span> <span class="n">x</span>
    <span class="n">|</span> <span class="n">realtime</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">r</span><span class="n">::</span><span class="n">rs</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span>
      <span class="n">foldl</span> <span class="p">(</span><span class="k">fn</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span> <span class="n">=&gt;</span>
                <span class="p">(</span><span class="n">Time</span>.<span class="n">+</span><span class="p">)</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">realtime</span> <span class="n">result</span><span class="p">)</span><span class="p">)</span>
            <span class="p">(</span><span class="n">realtime</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">rs</span><span class="p">;</span></pre>

<h3>Counting results</h3>

<p>
We can count the number of successes as follows:
</p>

<ul><li>
<p>
For a test result describing a single test case, if the outcome was
a <code>Success</code>, then return 1; otherwise, return 0.
</p>
</li>
<li>
<p>
For a test suite, simply sum the number of successes for each result
for all tests in the suite.
</p>
</li>
</ul>

<p>
This could be improved slightly by changing the test suite code to
something like
<code>foldl (fn (outcome, acc) (acc + (count_successes outcome))) 0 outcomes</code>
which avoids creating a temporary list.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">count_successes</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">Success</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="m">1</span>
    <span class="n">|</span> <span class="n">count_successes</span> <span class="p">(</span><span class="n">Case</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span> <span class="m">0</span> 
    <span class="n">|</span> <span class="n">count_successes</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">outcomes</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span>
      <span class="n">foldl</span> <span class="p">(</span><span class="k">op</span> <span class="n">+</span><span class="p">)</span> <span class="m">0</span> <span class="p">(</span><span class="n">map</span> <span class="n">count_successes</span> <span class="n">outcomes</span><span class="p">)</span><span class="p">;</span></pre>

<p>
The reasoning is similar for counting failures and errors.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">count_failures</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">Failure</span> <span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="m">1</span>
    <span class="n">|</span> <span class="n">count_failures</span> <span class="p">(</span><span class="n">Case</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span> <span class="m">0</span>
    <span class="n">|</span> <span class="n">count_failures</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">outcomes</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span>
      <span class="n">foldl</span> <span class="p">(</span><span class="k">op</span> <span class="n">+</span><span class="p">)</span> <span class="m">0</span> <span class="p">(</span><span class="n">map</span> <span class="n">count_failures</span> <span class="n">outcomes</span><span class="p">)</span><span class="p">;</span>

  <span class="k">fun</span> <span class="n">count_errors</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">Error</span> <span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="m">1</span>
    <span class="n">|</span> <span class="n">count_errors</span> <span class="p">(</span><span class="n">Case</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span> <span class="m">0</span>
    <span class="n">|</span> <span class="n">count_errors</span> <span class="p">(</span><span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">outcomes</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span>
      <span class="n">foldl</span> <span class="p">(</span><span class="k">op</span> <span class="n">+</span><span class="p">)</span> <span class="m">0</span> <span class="p">(</span><span class="n">map</span> <span class="n">count_errors</span> <span class="n">outcomes</span><span class="p">)</span><span class="p">;</span></pre>

<p>
We also want to eventually tally the total number of tests run for a
result, and this just adds up the previous three functions.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">count_total</span> <span class="n">x</span> <span class="n">=</span>
    <span class="n">count_successes</span> <span class="n">x</span> <span class="n">+</span> <span class="n">count_failures</span> <span class="n">x</span> <span class="n">+</span> <span class="n">count_errors</span> <span class="n">x</span><span class="p">;</span></pre>

<h3>Predicates for each outcome</h3>

<p>
How do we know if a test has run "successfully" or not?
</p>

<p>
Well, for a test case, we can determine this by inspecting the
outcome, and seeing if it is a <code>Success</code> or not.
</p>

<p>
For a test <i>suite</i>, that's a bit trickier. We will consider a test
suite as executing "successfully" if every test in the suite has
executed successfully. This is a bit recursive.
</p>

<p>
Fortunately, this means the number of successes is equal to the number
of tests. And this works for both test suites and test cases.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">is_success</span> <span class="n">x</span> <span class="n">=</span> <span class="p">(</span><span class="n">count_total</span> <span class="n">x</span><span class="p">)</span> <span class="n">=</span> <span class="p">(</span><span class="n">count_successes</span> <span class="n">x</span><span class="p">)</span><span class="p">;</span></pre>

<p>
Now we have the trickier cases. When does a test "fail"? For a test
case, this is when the outcome is <code>Failure</code>.
</p>

<p>
For a test suite, is it when all tests have failed? If just one test
fails, is it considered a "successful" execution? No, success only
occurs when all tests have executed successfully. So if at least one
fails or throws an unexpected assertion, then the test suite executed
<i>unsuccessfully.</i>
</p>

<p>
We should think of a test suite as failing if at least one failure has
occurred.
</p>

<p>
But what about an "error" outcome from executing a test suite? Now we
have a serious logic problem: are these predicates mutually exclusive
(i.e., exactly one of them is true)? Or will <code>is_failure</code> and
<code>is_error</code> permit some overlap/redundancy?
</p>

<p>
Well, either design choice seems reasonable. We will adopt the
convention that <i>any</i> failure qualifies as <code>is_failure</code>, and that
<i>any</i> error qualifies as <code>is_error</code>.
</p>

<p>
The implementation for these predicates are then:
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">is_failure</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span> <span class="n">Failure</span> <span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">true</span>
    <span class="n">|</span> <span class="n">is_failure</span> <span class="p">(</span><span class="n">Case</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span> <span class="n">false</span>
    <span class="n">|</span> <span class="n">is_failure</span> <span class="p">(</span><span class="n">s</span> <span class="k">as</span> <span class="n">Suite</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span>
      <span class="p">(</span><span class="n">count_failures</span> <span class="n">s</span><span class="p">)</span> <span class="n">&gt;</span> <span class="m">0</span><span class="p">;</span>

  <span class="k">fun</span> <span class="n">is_error</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span> <span class="n">Error</span> <span class="p">_</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">true</span>
    <span class="n">|</span> <span class="n">is_error</span> <span class="p">(</span><span class="n">Case</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span> <span class="n">false</span>
    <span class="n">|</span> <span class="n">is_error</span> <span class="p">(</span><span class="n">s</span> <span class="k">as</span> <span class="n">Suite</span> <span class="p">_</span><span class="p">)</span> <span class="n">=</span>
      <span class="p">(</span><span class="n">count_errors</span> <span class="n">s</span><span class="p">)</span> <span class="n">&gt;</span> <span class="m">0</span><span class="p">;</span></pre>

<h3>Failure messages and exception messages</h3>

<p>
We will have a few convenience functions to produce:
</p>

<ol><li>
<p>
For test cases with a <code>Failure</code> outcome, produce the string
describing the failure message
</p>
</li>
<li>
<p>
For test cases with an <code>Error</code> outcome, produce the <code>exnMessage</code>
for the associated exception that was caught; and
</p>
</li>
<li>
<p>
The empty string for everything else.
</p>
</li>
</ol>

<p>
If we wanted to be <i>strictly</i> proper functional programmers, we should
return a <code>string option</code> &mdash; specifically <code>NONE</code> instead of the empty
string. This just causes extra busy work, so I'm being sloppy ("do as
I say, not as I do", etc.).
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">msg</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">Failure</span> <span class="n">msg</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">msg</span>
    <span class="n">|</span> <span class="n">msg</span> <span class="p">_</span> <span class="n">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

  <span class="k">fun</span> <span class="n">exn_message</span> <span class="p">(</span><span class="n">Case</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">Error</span> <span class="n">e</span><span class="p">)</span><span class="p">)</span> <span class="n">=</span> <span class="n">exnMessage</span> <span class="n">e</span>
    <span class="n">|</span> <span class="n">exn_message</span> <span class="p">_</span> <span class="n">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> </pre>

<h2>Reporting a test result</h2>

<p>
When we report a test result, we expect from the user two functions:
</p>

<ol><li>
<p>
<code>report_case : t -&gt; string</code> describing what we should do when
reporting the result for a test case;
</p>
</li>
<li>
<p>
<code>report_suite : t -&gt; t list -&gt; string</code> which takes a test suite and
all the results in that particular suite (observe &mdash; the test
results in a suite is otherwise inaccessible), then produce a
string for the test suite.
</p>
</li>
</ol>

<p>
This can be implemented as a function taking these two functions as
parameters, then produces a function <code>TestResult.t -&gt; string</code> using
these reporting functions to produce the result.
</p>

<pre data-lang="sml" class="src">  <span class="k">fun</span> <span class="n">report</span> <span class="n">case_report</span> <span class="n">suite_report</span> <span class="n">=</span>
    <span class="k">fn</span> <span class="p">(</span><span class="n">c</span> <span class="k">as</span> <span class="n">Case</span> <span class="p">_</span><span class="p">)</span> <span class="n">=&gt;</span> <span class="n">case_report</span> <span class="n">c</span>
    <span class="n">|</span> <span class="p">(</span><span class="n">s</span> <span class="k">as</span> <span class="n">Suite</span> <span class="p">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">results</span><span class="p">)</span><span class="p">)</span> <span class="n">=&gt;</span>
      <span class="n">suite_report</span> <span class="n">s</span> <span class="n">results</span><span class="p">;</span></pre>

<p>
&hellip;and that's all! That's all we need for describing a test result.
</p>

<pre data-lang="sml" class="src"><span class="k">end</span><span class="p">;</span></pre>

<p>
The reader might find it a fun exercise to capture anything written to
the <code>stdout</code> (and <code>stderr</code>) streams, and allow the user to access
these as strings. But I am content with what we have produced thus far.
</p>

<p>
<footer>
</p>

<p>
<b>[</b>
<a href="./test.html">Back</a> <b>|</b> <a href="./index.html">Up</a> <b>|</b> <a href="./reporter.html">Next</a>
<b>]</b>
</p>

<p>
</footer>
</p>

</main>

</body>
</html>
