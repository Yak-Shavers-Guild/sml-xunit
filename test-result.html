<!doctype html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<title>Test Results</title>
<link type="text/css" rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
onload="renderMathInElement(document.body);"></script>
<script>
    // https://github.com/KaTeX/KaTeX/blob/main/docs/autorender.md
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            // customised options
            // auto-render specific keys, e.g.:
                delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: '\\(', right: '\\)', display: false},
                {left: '\\[', right: '\\]', display: true},
                {left: "\begin{equation}", right: "\end{equation}", display: true},
                {left: "\begin{align}", right: "\end{align}", display: true},
            ],
            // rendering keys, e.g.:
            throwOnError : false
        });
    });
 </script>

</head>
<body>
<main>

<p>
<nav class="crumbs">
</p>

<ul><li>
<p>
<a href="../index.html">ysg</a>
</p>
</li>
<li>
<p>
<a href="../sml/index.html">sml</a>
</p>
</li>
<li>
<p>
<a href="./index.html">xunit</a>
</p>
</li>
<li>
<p>
result
</p>
</li>
</ul>

<p>
</nav>
</p>

<h1>Test Results</h1>

<h2>Specification for Test Result Module</h2>

<p>
The common practice is that, when we're describing a data structure,
we create a module for it with a <code>type t</code> for the type of the data
structure. We follow this rule when specifyign the test result module.
</p>

<p>
We need the following methods:
</p>

<ul><li>
<p>
Smart constructors which will run a test case (or test suite) once,
and record all the information for it. These will
be <code>TestResult.for_case</code> and <code>TestResult.for_suite</code>
</p>
</li>
<li>
<p>
Reporting results. We don't know what the user will want. So we
allow the user to give us two functions <code>report_case : t -&gt; string</code> 
and <code>report_suite : t -&gt; t list -&gt; string</code> which will then
parametrize a function <code>t -&gt; string</code> reporting the results of a
particular run to the user as a string.
</p>
</li>
<li>
<p>
We want accessor functions for various fields.
</p>
</li>
<li>
<p>
We want predicates testing if the test result records a success,
failure, or error.
</p>
</li>
<li>
<p>
We want to count the number of successes, failures, and errors which
occurred when running a test. For test cases, these will be at most
1.
</p>
</li>
</ul>

<p>
And that's it! It <i>sounds</i> scarier than it is. Let us scribble this
specification down, then run over to its implementation.
</p>

<p>
(Note: if the user <i>wants</i> to capture everything printed to <code>stdout</code>
and <code>stderr</code>, Reppy and Gansner's <cite class="book">The Standard ML
Basis Library</cite> gives some pointers in section 8.2.4.)
</p>

<pre data-lang="sml" class="src">(*
TODO: capture everything printed to stdout and stderr, then
allow the user access to these strings.
*)
signature TEST_RESULT = sig
  type t;
  val for_case : string -&gt; (unit -&gt; unit) -&gt; t;
  val for_suite : string -&gt; (unit -&gt; (t list)) -&gt; t;

  val report : (t -&gt; string) -&gt; (t -&gt; t list -&gt; string) -&gt; t -&gt; string;

  val name : t -&gt; string;
  val msg : t -&gt; string;
  val exn_message : t -&gt; string;
  (* realtime excludes the time it took a TestSuite to
   allocate infrastructure in memory. *)
  val realtime : t -&gt; Time.time;
  val runtime : t -&gt; Time.time;
  
  val is_success : t -&gt; bool;
  val is_failure : t -&gt; bool;
  val is_error : t -&gt; bool;

  val count_successes : t -&gt; int;
  val count_failures : t -&gt; int;
  val count_errors : t -&gt; int;
  val count_total : t -&gt; int;
end;</pre>

<h2>Types for Test Results</h2>

<p>
The first thing we want to do is introduce types for test
results.
</p>

<p>
First, there is the type describing the conceivable outcomes of a
test. We agreed that a test could: succeed, fail with a message, or an
exception could be raised (and we'd count this as an "error"
situation).
</p>

<p>
Then, when we run a test case, we want to store its name, the time
interval for running the test, and the outcome.
</p>

<p>
When running a test suite, we want to remember its name, the time
interval it took to run it, and the results for every test in the
suite (<b>NOT</b> the outcomes &mdash; what good would this do for nested
test suites?).
</p>

<pre data-lang="sml" class="src">structure TestResult :&gt; TEST_RESULT = struct
  datatype Outcome = Success
                   | Failure of string
                   | Error of exn;
  
  datatype t = Case of string * Time.time * Outcome
             | Suite of string * Time.time * (t list);</pre>

<h2>Smart Constructors</h2>

<p>
OK, the basic plan for constructing a test result for a test case is:
</p>

<ul><li>
<p>
Given the name (as a string) and the four-phase procedure as a
function
</p>
</li>
<li>
<p>
We will record the start time
</p>
</li>
<li>
<p>
Then we will execute the four-phase assertion function.
</p>
</li>
<li>
<p>
In the default case (no exception is raised), we record the stop
time, and construct a result object for a test case saving the name,
time interval, and a "success" outcome. This is returned to the
user.
</p>
</li>
<li>
<p>
If an <code>Assert.Failure msg</code> was raised, then we record the stop time,
and construct a test result instance with a "failure" outcome
(saving the <code>msg</code> parameter). Then we return this to the user.
</p>
</li>
<li>
<p>
If any other exception <code>e</code> was raised, we record the stop time, and
construct the test result recording the test case's name, the time
interval it took to run, and that an "error" outcome with exception
<code>e</code> occurred.
</p>
</li>
</ul>

<p>
Strictly speaking, we could use a <a href="https://smlfamily.github.io/Basis/timer.html"><code>Timer</code></a>
if we wanted to check the CPU time consumed.
</p>

<pre data-lang="sml" class="src">  fun for_case name assertion =
    let
      val start = Time.now();
    in
      (assertion();
       Case(name,
            (Time.-)(Time.now(), start),
            Success))
      handle Assert.Failure msg =&gt;
             Case (name,
                   (Time.-)(Time.now(), start),
                   Failure msg)
             | e =&gt; Case(name,
                         (Time.-)(Time.now(), start),
                         Error e)
    end;</pre>

<p>
For a test suite, we simply record the start time, then determine the
results for every test in the suite. Once these results have been
tabulated, we record the interval <code>dt</code> it took to run all these tests.
</p>

<p>
Then we save these results in a test result object for a test suite.
</p>

<pre data-lang="sml" class="src">  fun for_suite name form_results =
    let
      val start = Time.now();
      val results = form_results ();
      val dt = (Time.-)(Time.now(), start);
    in
      Suite (name, dt, results)
    end;</pre>

<h2>Accessor functions</h2>

<p>
We want to hide the implementation details <b>entirely</b> from the user. 
This forces us to produce a large number of functions for obtaining
information about a test result.
</p>

<p>
The user may want to know the name of the test which was run. This is
a simple accessor function.
</p>

<pre data-lang="sml" class="src">(* *** accessor functions *** *)
  
  fun name (Case (n,_,_)) = n
    | name (Suite (n,_,_)) = n;</pre>

<p>
Now, we may want to know the time it took to run the test. This will
possibly include some overhead from the test suite, so we offer two
functions for determining the time it took: the <code>runtime</code> is simply
the time intervals stored in the test result object.
</p>

<p>
The <code>real_time</code> computes the time interval for results from test
suites by summing the time intervals in the result objects for
test cases only. These two functions are the same for test case
results.
</p>

<pre data-lang="sml" class="src">  (* runtime : t -&gt; Time.time

How long did it take to run the test(s) and construct the
result(s)? *)
  fun runtime (Case (_,dt,_)) = dt
    | runtime (Suite (_,dt,_)) = dt;

  (* realtime : t -&gt; Time.time

How long did it take just to run the test(s)? *)
  fun realtime (Case (_,dt,_)) = dt
    | realtime (Suite (_,_,[])) = Time.zeroTime
    | realtime (Suite (_,_,[x])) = realtime x
    | realtime (Suite (_,_,r::rs)) =
      foldl (fn (result,dt) =&gt;
                (Time.+)(dt, realtime result))
            (realtime r)
            rs;</pre>

<h3>Counting results</h3>

<p>
We can count the number of successes as follows:
</p>

<ul><li>
<p>
For a test result describing a single test case, if the outcome was
a <code>Success</code>, then return 1; otherwise, return 0.
</p>
</li>
<li>
<p>
For a test suite, simply sum the number of successes for each result
for all tests in the suite.
</p>
</li>
</ul>

<pre data-lang="sml" class="src">  fun count_successes (Case (_,_,Success)) = 1
    | count_successes (Case _) = 0 
    | count_successes (Suite (_,_,outcomes)) =
      foldl (op +) 0 (map count_successes outcomes);</pre>

<p>
The reasoning is similar for counting failures and errors.
</p>

<pre data-lang="sml" class="src">  fun count_failures (Case (_,_,Failure _)) = 1
    | count_failures (Case _) = 0
    | count_failures (Suite (_,_,outcomes)) =
      foldl (op +) 0 (map count_failures outcomes);

  fun count_errors (Case (_,_,Error _)) = 1
    | count_errors (Case _) = 0
    | count_errors (Suite (_,_,outcomes)) =
      foldl (op +) 0 (map count_errors outcomes);</pre>

<p>
We also want to eventually tally the total number of tests run for a
result, and this just adds up the previous three functions.
</p>

<pre data-lang="sml" class="src">  fun count_total x =
    count_successes x + count_failures x + count_errors x;</pre>

<h3>Predicates for each outcome</h3>

<p>
How do we know if a test has run "successfully" or not?
</p>

<p>
Well, for a test case, we can determine this by inspecting the
outcome, and seeing if it is a <code>Success</code> or not.
</p>

<p>
For a test <i>suite</i>, that's a bit trickier. We will consider a test
suite as executing "successfully" if every test in the suite has
executed successfully. This is a bit recursive.
</p>

<p>
Fortunately, this means the number of successes is equal to the number
of tests. And this works for both test suites and test cases.
</p>

<pre data-lang="sml" class="src">  fun is_success x = (count_total x) = (count_successes x);</pre>

<p>
Now we have the trickier cases. When does a test "fail"? For a test
case, this is when the outcome is <code>Failure</code>.
</p>

<p>
For a test suite, is it when all tests have failed? If just one test
fails, is it considered a "successful" execution? No, success only
occurs when all tests have executed successfully. So if at least one
fails or throws an unexpected assertion, then the test suite executed
<i>unsuccessfully.</i>
</p>

<p>
We should think of a test suite as failing if at least one failure has
occurred.
</p>

<p>
But what about an "error" outcome from executing a test suite? Now we
have a serious logic problem: are these predicates mutually exclusive
(i.e., exactly one of them is true)? Or will <code>is_failure</code> and
<code>is_error</code> permit some overlap/redundancy?
</p>

<p>
Well, either design choice seems reasonable. We will adopt the
convention that <i>any</i> failure qualifies as <code>is_failure</code>, and that
<i>any</i> error qualifies as <code>is_error</code>.
</p>

<p>
The implementation for these predicates are then:
</p>

<pre data-lang="sml" class="src">  fun is_failure (Case (_,_, Failure _)) = true
    | is_failure (Case _) = false
    | is_failure (s as Suite _) =
      (count_failures s) &gt; 0;

  fun is_error (Case (_,_, Error _)) = true
    | is_error (Case _) = false
    | is_error (s as Suite _) =
      (count_errors s) &gt; 0;</pre>

<h3>Failure messages and exception messages</h3>

<p>
We will have a few convenience functions to produce:
</p>

<ol><li>
<p>
For test cases with a <code>Failure</code> outcome, produce the string
describing the failure message
</p>
</li>
<li>
<p>
For test cases with an <code>Error</code> outcome, produce the <code>exnMessage</code>
for the associated exception that was caught; and
</p>
</li>
<li>
<p>
The empty string for everything else.
</p>
</li>
</ol>

<p>
If we wanted to be <i>strictly</i> proper functional programmers, we should
return a <code>string option</code> &mdash; specifically <code>NONE</code> instead of the empty
string. This just causes extra busy work, so I'm being sloppy ("do as
I say, not as I do", etc.).
</p>

<pre data-lang="sml" class="src">  fun msg (Case (_,_,Failure msg)) = msg
    | msg _ = &quot;&quot;;

  fun exn_message (Case (_,_,Error e)) = exnMessage e
    | exn_message _ = &quot;&quot;; </pre>

<h2>Reporting a test result</h2>

<p>
When we report a test result, we expect from the user two functions:
</p>

<ol><li>
<p>
<code>report_case : t -&gt; string</code> describing what we should do when
reporting the result for a test case;
</p>
</li>
<li>
<p>
<code>report_suite : t -&gt; t list -&gt; string</code> which takes a test suite and
all the results in that particular suite (observe &mdash; the test
results in a suite is otherwise inaccessible), then produce a
string for the test suite.
</p>
</li>
</ol>

<p>
This can be implemented as a function taking these two functions as
parameters, then produces a function <code>TestResult.t -&gt; string</code> using
these reporting functions to produce the result.
</p>

<pre data-lang="sml" class="src">  fun report case_report suite_report =
    fn (c as Case _) =&gt; case_report c
    | (s as Suite (_,_,results)) =&gt;
      suite_report s results;</pre>

<p>
&hellip;and that's all! That's all we need for describing a test result.
</p>

<pre data-lang="sml" class="src">end;</pre>

<p>
The reader might find it a fun exercise to capture anything written to
the <code>stdout</code> (and <code>stderr</code>) streams, and allow the user to access
these as strings. But I am content with what we have produced thus far.
</p>

<p>
<footer>
</p>

<p>
<b>[</b>
<a href="./test.html">Back</a> <b>|</b> <a href="./index.html">Up</a> <b>|</b> <a href="./reporter.html">Next</a>
<b>]</b>
</p>

<p>
</footer>
</p>

</main>

</body>
</html>
